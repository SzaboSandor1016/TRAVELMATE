package com.example.travel_mate.data

import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.launch
import kotlinx.coroutines.suspendCancellableCoroutine
import kotlinx.coroutines.withContext
import kotlin.coroutines.coroutineContext
import kotlin.coroutines.resume

/** [com.example.travel_mate.RoomLocalDataSourceImpl]
 * a class that implements [RoomLocalDataSource]
 *
 * It has methods to fetch and delete methods for locally [Trip]s
 */
class RoomLocalDataSourceImpl ( appDatabase: AppDatabase): RoomLocalDataSource {



    val tripDao = appDatabase.tripDao()

    /** [uploadTrip]
     * upload the [Trip] to the [androidx.room.Room] local database
     * it is also the update method.
     * It replaces the [Trip] in the database if already exists
     */
    override suspend fun uploadTrip(trip: Trip) {

        CoroutineScope(coroutineContext).launch {

            tripDao.uploadTrip(
                trip = trip,
                places = trip.places.map { it.copy(
                    tripId = trip.uUID
                ) }
            )
        }
    }

    /** [deleteTrip]
     * delete the [Trip] from the [androidx.room.Room] local database
     */
    override suspend fun deleteTrip(trip: Trip) {

        CoroutineScope(coroutineContext).launch {

            tripDao.deleteTrip(
                trip = trip,
                places = trip.places
            )
        }
    }

    /** [findTripById]
     * returns the [Trip] with the [uuid] passed as a parameter
     */
    override suspend fun findTripById(uuid: String): Trip {

        return withContext(Dispatchers.IO) {
            val tripWithPlaces = async {
                tripDao.findTripByUUID(
                    uuid = uuid
                )
            }

            Log.d("LocalDataSource", tripWithPlaces.await().trips.uUID.toString())
            Log.d("LocalDataSource", tripWithPlaces.await().trips.places.size.toString())

            val trip = tripWithPlaces.await().component1().copy(
                uUID = uuid,
                places = tripWithPlaces.await().component2()
            )

            return@withContext trip
        }
    }

    /** [fetchTripIdentifiers]
     * returns a [List] of [TripRepositoryImpl.TripIdentifier]s
     * generated by the [TripDao.getAllTripIdentifiers] functions after setting their location property to local
     */
    override suspend fun fetchTripIdentifiers(): List<TripRepositoryImpl.TripIdentifier>
    = suspendCancellableCoroutine { continuation ->

        val tripIdentifiers = tripDao.getAllTripIdentifiers().map {
            it.copy(
                location = "local"
            )
        }

        continuation.resume(tripIdentifiers)
    }


    /*private fun <T> convertClassToJson(classToConvert: T ): String{

        return Gson().toJson(classToConvert)

    }

    private fun <T> processReadString(readString: String, classType: Class<T>): List<T> {
        val gson = Gson()
        val type = TypeToken.getParameterized(ArrayList::class.java, classType).type
        return gson.fromJson<ArrayList<T>?>(readString, type).toList()
    }

    override suspend fun checkFileExists(fileName: String): Boolean{

        return withContext(Dispatchers.IO) {

            return@withContext File(MyApplication.appContext.filesDir, fileName).exists()

        }
    }

    override suspend fun <T> writeStorage(classesToWrite: List<T>, fileName: String){

        withContext(Dispatchers.IO) {

            val contentString = StringBuilder()

            contentString.append("[")

            contentString.append(
                classesToWrite.joinToString(separator = ",\n") { convertClassToJson(it) }
            )
            contentString.append("]")

            MyApplication.appContext.openFileOutput(fileName, Context.MODE_PRIVATE).use {
                it.write(contentString.toString().toByteArray())
            }
        }
    }
    override suspend fun <T> readStorage(fileName: String, classType: Class<T>): List<T> {

        return withContext(Dispatchers.IO) {
            val file = File(MyApplication.appContext.filesDir, fileName)
            val readString = file.readText()

            processReadString(readString, classType)
        }
    }*/

}