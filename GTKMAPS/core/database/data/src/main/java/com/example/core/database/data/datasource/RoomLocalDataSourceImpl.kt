package com.example.core.database.data.datasource

import com.example.core.database.domain.datasource.RoomLocalDataSource
import com.example.core.databse.dao.TripDao
import com.example.core.databse.dao.models.DayOfTripLocalEntityModel
import com.example.core.databse.dao.models.PlaceLocalEntityModel
import com.example.core.databse.dao.models.TripLocalEntityModel
import com.example.core.databse.dao.models.TripIdentifierLocalEntityModel
import kotlinx.coroutines.flow.Flow

/** [com.example.travel_mate.RoomLocalDataSourceImpl]
 * a class that implements [com.example.travel_mate.data.RoomLocalDataSource]
 *
 * It has methods to fetch and delete methods for locally [com.example.travel_mate.data.Trip]s
 */
class RoomLocalDataSourceImpl(
    private val tripDao: TripDao
): RoomLocalDataSource {

    /** [uploadTrip]
     * upload the [com.example.travel_mate.data.Trip] to the [androidx.room.Room] local database
     * it is also the update method.
     * It replaces the [com.example.travel_mate.data.Trip] in the database if already exists
     */
    override fun uploadTrip(
        trip: TripLocalEntityModel,
        days: List<DayOfTripLocalEntityModel>,
        places: List<PlaceLocalEntityModel>,
        originalDays: List<DayOfTripLocalEntityModel>,
        originalPlaces: List<PlaceLocalEntityModel>
    ) {
        deleteOriginalDays(
            days = originalDays,
            places = originalPlaces
        )

        tripDao.uploadTrip(
            trip = trip,
            days = days,
            places = places
        )
    }

    /** [deleteTrip]
     * delete the [com.example.travel_mate.data.Trip] from the [androidx.room.Room] local database
     */
    override fun deleteTrip(
        uuid: String
    ) {

        val trip = findTripById(uuid)

        tripDao.deleteTrip(
            trip = trip.trip,
            days = trip.days.map { it.day },
            places = trip.days.flatMap { it.places }
        )
    }

    private fun deleteOriginalDays(
        days: List<DayOfTripLocalEntityModel>,
        places: List<PlaceLocalEntityModel>
    ) {
        tripDao.deleteOriginalDays(
            days = days,
            places = places
        )
    }

    /** [findTripById]
     * returns the [com.example.travel_mate.data.Trip] with the [uuid] passed as a parameter
     */
    override fun findTripById(uuid: String): TripDao.TripWithDaysAndPlaces {

        return tripDao.findTripByUUID(
                uuid = uuid
            )
    }

    /** [fetchTripIdentifiers]
     * returns a [List] of [com.example.travel_mate.data.TripRepositoryImpl.TripIdentifier]s
     * generated by the [TripDao.getAllTripIdentifiers] functions after setting their location property to local
     */
    override fun fetchTripIdentifiers(): Flow<List<TripIdentifierLocalEntityModel>> {

        return tripDao.getAllTripIdentifiers()/*.map { tripIdentifiers ->
            tripIdentifiers.map {
                it*//*.toTripIdentifierTripsDomainModel().copy(
                location = "local"
            )*//*
            }
        }*/
    }


    /*private fun <T> convertClassToJson(classToConvert: T ): String{

        return Gson().toJson(classToConvert)

    }

    private fun <T> processReadString(readString: String, classType: Class<T>): List<T> {
        val gson = Gson()
        val type = TypeToken.getParameterized(ArrayList::class.java, classType).type
        return gson.fromJson<ArrayList<T>?>(readString, type).toList()
    }

    override suspend fun checkFileExists(fileName: String): Boolean{

        return withContext(Dispatchers.IO) {

            return@withContext File(MyApplication.appContext.filesDir, fileName).exists()

        }
    }

    override suspend fun <T> writeStorage(classesToWrite: List<T>, fileName: String){

        withContext(Dispatchers.IO) {

            val contentString = StringBuilder()

            contentString.append("[")

            contentString.append(
                classesToWrite.joinToString(separator = ",\n") { convertClassToJson(it) }
            )
            contentString.append("]")

            MyApplication.appContext.openFileOutput(fileName, Context.MODE_PRIVATE).use {
                it.write(contentString.toString().toByteArray())
            }
        }
    }
    override suspend fun <T> readStorage(fileName: String, classType: Class<T>): List<T> {

        return withContext(Dispatchers.IO) {
            val file = File(MyApplication.appContext.filesDir, fileName)
            val readString = file.readText()

            processReadString(readString, classType)
        }
    }*/

}